From f74450953a6689043fc65f57825ae1bb6eae2fb8 Mon Sep 17 00:00:00 2001
From: Filip Varga <fivarga@cisco.com>
Date: Sat, 27 Jul 2019 10:08:48 -0400
Subject: [PATCH] nat: rewrite for multi-worker support

Type: fix

Change-Id: I07e0338f5c685155d8c198452f17902f5af43b7f
Signed-off-by: Filip Varga <fivarga@cisco.com>
---

diff --git a/src/plugins/nat/in2out.c b/src/plugins/nat/in2out.c
index 8bdb792..c69bc61 100755
--- a/src/plugins/nat/in2out.c
+++ b/src/plugins/nat/in2out.c
@@ -210,7 +210,7 @@
     {
       s_kv.key = s->out2in.as_u64;
       if (clib_bihash_add_del_8_8 (&tsm->out2in, &s_kv, 0))
-	nat_log_warn ("out2in key del failed");
+	nat_elog_warn ("out2in key del failed");
 
       snat_ipfix_logging_nat44_ses_delete (ctx->thread_index,
 					   s->in2out.addr.as_u32,
@@ -271,7 +271,7 @@
     {
       b0->error = node->errors[SNAT_IN2OUT_ERROR_MAX_SESSIONS_EXCEEDED];
       nat_ipfix_logging_max_sessions (thread_index, sm->max_translations);
-      nat_log_notice ("maximum sessions exceeded");
+      nat_elog_notice ("maximum sessions exceeded");
       return SNAT_IN2OUT_NEXT_DROP;
     }
 
@@ -307,7 +307,7 @@
 			      thread_index);
   if (!u)
     {
-      nat_log_warn ("create NAT user failed");
+      nat_elog_warn ("create NAT user failed");
       return SNAT_IN2OUT_NEXT_DROP;
     }
 
@@ -315,7 +315,7 @@
   if (!s)
     {
       nat44_delete_user_with_no_session (sm, u, thread_index);
-      nat_log_warn ("create NAT session failed");
+      nat_elog_warn ("create NAT session failed");
       return SNAT_IN2OUT_NEXT_DROP;
     }
 
@@ -363,7 +363,7 @@
   if (clib_bihash_add_or_overwrite_stale_8_8
       (&sm->per_thread_data[thread_index].in2out, &kv0,
        nat44_i2o_is_idle_session_cb, &ctx0))
-    nat_log_notice ("in2out key add failed");
+    nat_elog_notice ("in2out key add failed");
 
   kv0.key = s->out2in.as_u64;
   kv0.value = s - sm->per_thread_data[thread_index].sessions;
@@ -371,7 +371,7 @@
   if (clib_bihash_add_or_overwrite_stale_8_8
       (&sm->per_thread_data[thread_index].out2in, &kv0,
        nat44_o2i_is_idle_session_cb, &ctx0))
-    nat_log_notice ("out2in key add failed");
+    nat_elog_notice ("out2in key add failed");
 
   /* log NAT event */
   snat_ipfix_logging_nat44_ses_create (thread_index,
@@ -1777,7 +1777,7 @@
 	    {
 	      next0 = SNAT_IN2OUT_NEXT_DROP;
 	      b0->error = node->errors[SNAT_IN2OUT_ERROR_MAX_REASS];
-	      nat_log_notice ("maximum reassemblies exceeded");
+	      nat_elog_notice ("maximum reassemblies exceeded");
 	      goto trace0;
 	    }
 
@@ -1844,7 +1844,7 @@
 		      (thread_index, reass0, bi0, &fragments_to_drop))
 		    {
 		      b0->error = node->errors[SNAT_IN2OUT_ERROR_MAX_FRAG];
-		      nat_log_notice
+		      nat_elog_notice
 			("maximum fragments per reassembly exceeded");
 		      next0 = SNAT_IN2OUT_NEXT_DROP;
 		      goto trace0;
diff --git a/src/plugins/nat/in2out_ed.c b/src/plugins/nat/in2out_ed.c
index 3bcde10..60f820a 100644
--- a/src/plugins/nat/in2out_ed.c
+++ b/src/plugins/nat/in2out_ed.c
@@ -190,7 +190,7 @@
       ed_kv.key[0] = ed_key.as_u64[0];
       ed_kv.key[1] = ed_key.as_u64[1];
       if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &ed_kv, 0))
-	nat_log_warn ("out2in_ed key del failed");
+	nat_elog_warn ("out2in_ed key del failed");
 
       if (snat_is_unk_proto_session (s))
 	goto delete;
@@ -299,7 +299,7 @@
     {
       b->error = node->errors[NAT_IN2OUT_ED_ERROR_MAX_SESSIONS_EXCEEDED];
       nat_ipfix_logging_max_sessions (thread_index, sm->max_translations);
-      nat_log_notice ("maximum sessions exceeded");
+      nat_elog_notice ("maximum sessions exceeded");
       return NAT_IN2OUT_ED_NEXT_DROP;
     }
 
@@ -318,7 +318,7 @@
 					       sm->port_per_thread,
 					       tsm->snat_thread_index))
 	{
-	  nat_log_notice ("addresses exhausted");
+	  nat_elog_notice ("addresses exhausted");
 	  b->error = node->errors[NAT_IN2OUT_ED_ERROR_OUT_OF_PORTS];
 	  return NAT_IN2OUT_ED_NEXT_DROP;
 	}
@@ -346,7 +346,7 @@
   u = nat_user_get_or_create (sm, &key->l_addr, rx_fib_index, thread_index);
   if (!u)
     {
-      nat_log_warn ("create NAT user failed");
+      nat_elog_warn ("create NAT user failed");
       if (!is_sm)
 	snat_free_outside_address_and_port (sm->addresses,
 					    thread_index, &key1);
@@ -357,7 +357,7 @@
   if (!s)
     {
       nat44_delete_user_with_no_session (sm, u, thread_index);
-      nat_log_warn ("create NAT session failed");
+      nat_elog_warn ("create NAT session failed");
       if (!is_sm)
 	snat_free_outside_address_and_port (sm->addresses,
 					    thread_index, &key1);
@@ -409,7 +409,7 @@
   if (clib_bihash_add_or_overwrite_stale_16_8 (&tsm->in2out_ed, kv,
 					       nat44_i2o_ed_is_idle_session_cb,
 					       &ctx))
-    nat_log_notice ("in2out-ed key add failed");
+    nat_elog_notice ("in2out-ed key add failed");
 
   make_ed_kv (kv, &key1.addr, &key->r_addr, key->proto, s->out2in.fib_index,
 	      key1.port, key->r_port);
@@ -417,7 +417,7 @@
   if (clib_bihash_add_or_overwrite_stale_16_8 (&tsm->out2in_ed, kv,
 					       nat44_o2i_ed_is_idle_session_cb,
 					       &ctx))
-    nat_log_notice ("out2in-ed key add failed");
+    nat_elog_notice ("out2in-ed key add failed");
 
   *sessionp = s;
 
@@ -562,8 +562,6 @@
       s = pool_elt_at_index (tsm->sessions, value.value);
       if (nat44_is_ses_closed (s))
 	{
-	  nat_log_debug ("TCP close connection %U", format_snat_session,
-			 &sm->per_thread_data[thread_index], s);
 	  nat_free_session_data (sm, s, thread_index, 0);
 	  nat44_delete_session (sm, s, thread_index);
 	}
@@ -780,7 +778,7 @@
 	{
 	  b->error = node->errors[NAT_IN2OUT_ED_ERROR_MAX_SESSIONS_EXCEEDED];
 	  nat_ipfix_logging_max_sessions (thread_index, sm->max_translations);
-	  nat_log_notice ("maximum sessions exceeded");
+	  nat_elog_notice ("maximum sessions exceeded");
 	  return 0;
 	}
 
@@ -788,7 +786,7 @@
 				  thread_index);
       if (!u)
 	{
-	  nat_log_warn ("create NAT user failed");
+	  nat_elog_warn ("create NAT user failed");
 	  return 0;
 	}
 
@@ -857,7 +855,7 @@
       if (!s)
 	{
 	  nat44_delete_user_with_no_session (sm, u, thread_index);
-	  nat_log_warn ("create NAT session failed");
+	  nat_elog_warn ("create NAT session failed");
 	  return 0;
 	}
 
@@ -878,13 +876,13 @@
 		  rx_fib_index, 0, 0);
       s_kv.value = s - tsm->sessions;
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &s_kv, 1))
-	nat_log_notice ("in2out key add failed");
+	nat_elog_notice ("in2out key add failed");
 
       make_ed_kv (&s_kv, &s->out2in.addr, &ip->dst_address, ip->protocol,
 		  outside_fib_index, 0, 0);
       s_kv.value = s - tsm->sessions;
       if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &s_kv, 1))
-	nat_log_notice ("out2in key add failed");
+	nat_elog_notice ("out2in key add failed");
     }
 
   /* Update IP checksum */
@@ -1860,7 +1858,7 @@
 	    {
 	      next0 = NAT_IN2OUT_ED_NEXT_DROP;
 	      b0->error = node->errors[NAT_IN2OUT_ED_ERROR_MAX_REASS];
-	      nat_log_notice ("maximum reassemblies exceeded");
+	      nat_elog_notice ("maximum reassemblies exceeded");
 	      goto trace0;
 	    }
 
@@ -1963,7 +1961,7 @@
 		      (thread_index, reass0, bi0, &fragments_to_drop))
 		    {
 		      b0->error = node->errors[NAT_IN2OUT_ED_ERROR_MAX_FRAG];
-		      nat_log_notice
+		      nat_elog_notice
 			("maximum fragments per reassembly exceeded");
 		      next0 = NAT_IN2OUT_ED_NEXT_DROP;
 		      goto trace0;
diff --git a/src/plugins/nat/nat.api b/src/plugins/nat/nat.api
index 4ce1db1..d63fdd7 100644
--- a/src/plugins/nat/nat.api
+++ b/src/plugins/nat/nat.api
@@ -42,6 +42,16 @@
   NAT_IS_EXT_HOST_VALID = 0x80,
 };
 
+enum nat_log_level : u8
+{
+  NAT_LOG_NONE = 0x00,
+  NAT_LOG_ERROR = 0x01,
+  NAT_LOG_WARNING = 0x02,
+  NAT_LOG_NOTICE = 0x03,
+  NAT_LOG_INFO = 0x04,
+  NAT_LOG_DEBUG = 0x05,
+};
+
 /** \brief Control ping from client to api server request
     @param client_index - opaque cookie to identify the sender
     @param context - sender context, to match reply w/ request
@@ -120,6 +130,17 @@
   u32 nat64_st_memory_size;
 };
 
+/** \brief Set NAT logging level
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+    @param log_level - logging level
+*/
+autoreply define nat_set_log_level {
+  u32 client_index;
+  u32 context;
+  vl_api_nat_log_level_t log_level;
+};
+
 /** \brief Set NAT workers
     @param client_index - opaque cookie to identify the sender
     @param context - sender context, to match reply w/ request
diff --git a/src/plugins/nat/nat.c b/src/plugins/nat/nat.c
index e6d4ae5..2dd2707 100755
--- a/src/plugins/nat/nat.c
+++ b/src/plugins/nat/nat.c
@@ -206,7 +206,7 @@
       ed_kv.key[0] = ed_key.as_u64[0];
       ed_kv.key[1] = ed_key.as_u64[1];
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &ed_kv, 0))
-	nat_log_warn ("in2out_ed key del failed");
+	nat_elog_warn ("in2out_ed key del failed");
       return;
     }
 
@@ -234,7 +234,7 @@
       ed_kv.key[0] = ed_key.as_u64[0];
       ed_kv.key[1] = ed_key.as_u64[1];
       if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &ed_kv, 0))
-	nat_log_warn ("out2in_ed key del failed");
+	nat_elog_warn ("out2in_ed key del failed");
       ed_key.l_addr = s->in2out.addr;
       ed_key.fib_index = s->in2out.fib_index;
       if (!snat_is_unk_proto_session (s))
@@ -247,7 +247,7 @@
       ed_kv.key[0] = ed_key.as_u64[0];
       ed_kv.key[1] = ed_key.as_u64[1];
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &ed_kv, 0))
-	nat_log_warn ("in2out_ed key del failed");
+	nat_elog_warn ("in2out_ed key del failed");
 
       if (!is_ha)
 	nat_syslog_nat44_sdel (s->user_index, s->in2out.fib_index,
@@ -261,10 +261,10 @@
     {
       kv.key = s->in2out.as_u64;
       if (clib_bihash_add_del_8_8 (&tsm->in2out, &kv, 0))
-	nat_log_warn ("in2out key del failed");
+	nat_elog_warn ("in2out key del failed");
       kv.key = s->out2in.as_u64;
       if (clib_bihash_add_del_8_8 (&tsm->out2in, &kv, 0))
-	nat_log_warn ("out2in key del failed");
+	nat_elog_warn ("out2in key del failed");
 
       if (!is_ha)
 	nat_syslog_nat44_apmdel (s->user_index, s->in2out.fib_index,
@@ -343,7 +343,7 @@
 
       /* add user */
       if (clib_bihash_add_del_8_8 (&tsm->user_hash, &kv, 1))
-	nat_log_warn ("user_hash keay add failed");
+	nat_elog_warn ("user_hash keay add failed");
 
       vlib_set_simple_counter (&sm->total_users, thread_index, 0,
 			       pool_elts (tsm->users));
@@ -475,8 +475,8 @@
       if ((u->nsessions + u->nstaticsessions) >=
 	  sm->max_translations_per_user)
 	{
-	  nat_log_warn ("max translations per user %U", format_ip4_address,
-			&u->addr);
+	  nat_elog_addr (SNAT_LOG_WARNING, "[warn] max translations per user",
+			 u->addr.as_u32);
 	  snat_ipfix_logging_max_entries_per_user
 	    (thread_index, sm->max_translations_per_user, u->addr.as_u32);
 	  return 0;
@@ -871,7 +871,7 @@
 		      foreach_snat_protocol
 #undef _
 		    default:
-		      nat_log_info ("unknown protocol");
+		      nat_elog_info ("unknown protocol");
 		      return VNET_API_ERROR_INVALID_VALUE_2;
 		    }
 		  break;
@@ -1053,7 +1053,7 @@
 		      foreach_snat_protocol
 #undef _
 		    default:
-		      nat_log_info ("unknown protocol");
+		      nat_elog_info ("unknown protocol");
 		      return VNET_API_ERROR_INVALID_VALUE_2;
 		    }
 		  break;
@@ -1234,7 +1234,7 @@
 		      foreach_snat_protocol
 #undef _
 		    default:
-		      nat_log_info ("unknown protocol");
+		      nat_elog_info ("unknown protocol");
 		      return VNET_API_ERROR_INVALID_VALUE_2;
 		    }
 		  break;
@@ -1271,7 +1271,7 @@
       kv.value = m - sm->static_mappings;
       if (clib_bihash_add_del_8_8 (&sm->static_mapping_by_external, &kv, 1))
 	{
-	  nat_log_err ("static_mapping_by_external key add failed");
+	  nat_elog_err ("static_mapping_by_external key add failed");
 	  return VNET_API_ERROR_UNSPECIFIED;
 	}
 
@@ -1347,7 +1347,7 @@
 		      foreach_snat_protocol
 #undef _
 		    default:
-		      nat_log_info ("unknown protocol");
+		      nat_elog_info ("unknown protocol");
 		      return VNET_API_ERROR_INVALID_VALUE_2;
 		    }
 		  break;
@@ -1362,7 +1362,7 @@
       kv.key = m_key.as_u64;
       if (clib_bihash_add_del_8_8 (&sm->static_mapping_by_external, &kv, 0))
 	{
-	  nat_log_err ("static_mapping_by_external key del failed");
+	  nat_elog_err ("static_mapping_by_external key del failed");
 	  return VNET_API_ERROR_UNSPECIFIED;
 	}
 
@@ -1379,7 +1379,7 @@
               kv.key = m_key.as_u64;
               if (clib_bihash_add_del_8_8(&sm->static_mapping_by_local, &kv, 0))
                 {
-                  nat_log_err ("static_mapping_by_local key del failed");
+                  nat_elog_err ("static_mapping_by_local key del failed");
                   return VNET_API_ERROR_UNSPECIFIED;
                 }
             }
@@ -1513,7 +1513,7 @@
 	  kv.key = m_key.as_u64;
 	  kv.value = m - sm->static_mappings;
 	  if (clib_bihash_add_del_8_8 (&sm->static_mapping_by_local, &kv, 1))
-	    nat_log_err ("static_mapping_by_local key add failed");
+	    nat_elog_err ("static_mapping_by_local key add failed");
 	}
     }
   else
@@ -1534,7 +1534,7 @@
 	  m_key.fib_index = match_local->fib_index;
 	  kv.key = m_key.as_u64;
 	  if (clib_bihash_add_del_8_8 (&sm->static_mapping_by_local, &kv, 0))
-	    nat_log_err ("static_mapping_by_local key del failed");
+	    nat_elog_err ("static_mapping_by_local key del failed");
 	}
 
       if (sm->num_workers > 1)
@@ -1669,7 +1669,7 @@
       /* Check if address is used in some static mapping */
       if (is_snat_address_used_in_static_mapping (sm, addr))
 	{
-	  nat_log_notice ("address used in static mapping");
+	  nat_elog_notice ("address used in static mapping");
 	  return VNET_API_ERROR_UNSPECIFIED;
 	}
     }
@@ -2297,6 +2297,7 @@
   sm->addr_and_port_alloc_alg = NAT_ADDR_AND_PORT_ALLOC_ALG_DEFAULT;
   sm->forwarding_enabled = 0;
   sm->log_class = vlib_log_register_class ("nat", 0);
+  sm->log_level = SNAT_LOG_NONE;
   sm->mss_clamping = 0;
 
   node = vlib_get_node_by_name (vm, (u8 *) "error-drop");
@@ -2463,7 +2464,7 @@
       foreach_snat_protocol
 #undef _
     default:
-      nat_log_info ("unknown protocol");
+      nat_elog_info ("unknown protocol");
       return;
     }
 }
@@ -2496,7 +2497,7 @@
 	  foreach_snat_protocol
 #undef _
 	default:
-	  nat_log_info ("unknown protocol");
+	  nat_elog_info ("unknown protocol");
 	  return 1;
 	}
     }
@@ -2553,26 +2554,50 @@
 	{
 	  if (PREDICT_FALSE (lb != 0))
 	    *lb = m->affinity ? AFFINITY_LB_NAT : LB_NAT;
-	  if (m->affinity)
+	  if (m->affinity && !nat_affinity_find_and_lock (ext_host_addr[0],
+							  match.addr,
+							  match.protocol,
+							  match.port,
+							  &backend_index))
 	    {
-	      if (nat_affinity_find_and_lock (ext_host_addr[0], match.addr,
-					      match.protocol, match.port,
-					      &backend_index))
-		goto get_local;
-
 	      local = pool_elt_at_index (m->locals, backend_index);
 	      mapping->addr = local->addr;
 	      mapping->port = clib_host_to_net_u16 (local->port);
 	      mapping->fib_index = local->fib_index;
 	      goto end;
 	    }
-	get_local:
-          /* *INDENT-OFF* */
-          pool_foreach_index (i, m->locals,
-          ({
-            vec_add1 (tmp, i);
-          }));
-          /* *INDENT-ON* */
+	  /* pick locals matching this worker
+	   */
+	  if (PREDICT_FALSE (sm->num_workers > 1))
+	    {
+	      u32 thread_index = vlib_get_thread_index ();
+              /* *INDENT-OFF* */
+              pool_foreach_index (i, m->locals,
+              ({
+                local = pool_elt_at_index (m->locals, i);
+
+                ip4_header_t ip = {
+		  .src_address = local->addr,
+	        };
+
+	        if (sm->worker_in2out_cb (&ip, m->fib_index) ==
+		    thread_index)
+                  {
+                    vec_add1 (tmp, i);
+                  }
+              }));
+              /* *INDENT-ON* */
+	      ASSERT (vec_len (tmp) != 0);
+	    }
+	  else
+	    {
+              /* *INDENT-OFF* */
+              pool_foreach_index (i, m->locals,
+              ({
+                vec_add1 (tmp, i);
+              }));
+              /* *INDENT-ON* */
+	    }
 	  hi = vec_len (tmp) - 1;
 	  local = pool_elt_at_index (m->locals, tmp[hi]);
 	  rand = 1 + (random_u32 (&sm->random_seed) % local->prefix);
@@ -2585,15 +2610,7 @@
 	  local = pool_elt_at_index (m->locals, tmp[lo]);
 	  if (!(local->prefix >= rand))
 	    return 1;
-	  if (PREDICT_FALSE (sm->num_workers > 1))
-	    {
-	      ip4_header_t ip = {
-		.src_address = local->addr,
-	      };
-	      if (sm->worker_in2out_cb (&ip, m->fib_index) !=
-		  vlib_get_thread_index ())
-		goto get_local;
-	    }
+
 	  mapping->addr = local->addr;
 	  mapping->port = clib_host_to_net_u16 (local->port);
 	  mapping->fib_index = local->fib_index;
@@ -2603,7 +2620,7 @@
 						match.protocol, match.port,
 						tmp[lo], m->affinity,
 						m->affinity_per_service_list_head_index))
-		nat_log_info ("create affinity record failed");
+		nat_elog_info ("create affinity record failed");
 	    }
 	  vec_free (tmp);
 	}
@@ -2709,7 +2726,7 @@
 	  foreach_snat_protocol
 #undef _
 	default:
-	  nat_log_info ("unknown protocol");
+	  nat_elog_info ("unknown protocol");
 	  return 1;
 	}
 
@@ -2740,7 +2757,7 @@
 	  foreach_snat_protocol
 #undef _
 	default:
-	  nat_log_info ("unknown protocol");
+	  nat_elog_info ("unknown protocol");
 	  return 1;
 	}
     }
@@ -2790,7 +2807,7 @@
       foreach_snat_protocol
 #undef _
     default:
-      nat_log_info ("unknown protocol");
+      nat_elog_info ("unknown protocol");
       return 1;
     }
 
@@ -2838,7 +2855,7 @@
       foreach_snat_protocol
 #undef _
     default:
-      nat_log_info ("unknown protocol");
+      nat_elog_info ("unknown protocol");
       return 1;
     }
 
@@ -3257,7 +3274,7 @@
   kv.key = key.as_u64;
   kv.value = s - tsm->sessions;
   if (clib_bihash_add_del_8_8 (&tsm->out2in, &kv, 1))
-    nat_log_warn ("out2in key add failed");
+    nat_elog_warn ("out2in key add failed");
 
   key.addr.as_u32 = in_addr->as_u32;
   key.port = in_port;
@@ -3265,7 +3282,7 @@
   s->in2out = key;
   kv.key = key.as_u64;
   if (clib_bihash_add_del_8_8 (&tsm->in2out, &kv, 1))
-    nat_log_warn ("in2out key add failed");
+    nat_elog_warn ("in2out key add failed");
 }
 
 void
@@ -3431,12 +3448,12 @@
 	      snat_proto_to_ip_proto (proto), fib_index, in_port,
 	      s->ext_host_nat_port);
   if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &kv, 1))
-    nat_log_warn ("in2out key add failed");
+    nat_elog_warn ("in2out key add failed");
 
   make_ed_kv (&kv, out_addr, eh_addr, snat_proto_to_ip_proto (proto),
 	      s->out2in.fib_index, out_port, eh_port);
   if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &kv, 1))
-    nat_log_warn ("out2in key add failed");
+    nat_elog_warn ("out2in key add failed");
 }
 
 void
@@ -3789,7 +3806,7 @@
 				rp->proto, !is_delete, rp->twice_nat,
 				rp->out2in_only, rp->tag, rp->identity_nat);
   if (rv)
-    nat_log_notice ("snat_add_static_mapping returned %d", rv);
+    nat_elog_notice_X1 ("snat_add_static_mapping returned %d", "i4", rv);
 }
 
 static void
@@ -3860,7 +3877,8 @@
 					    rp->out2in_only, rp->tag,
 					    rp->identity_nat);
 	      if (rv)
-		nat_log_notice ("snat_add_static_mapping returned %d", rv);
+		nat_elog_notice_X1 ("snat_add_static_mapping returned %d",
+				    "i4", rv);
 	    }
 	}
       return;
diff --git a/src/plugins/nat/nat.h b/src/plugins/nat/nat.h
index 237d945..ec4ed24 100644
--- a/src/plugins/nat/nat.h
+++ b/src/plugins/nat/nat.h
@@ -23,6 +23,7 @@
 #include <vnet/ethernet/ethernet.h>
 #include <vnet/ip/icmp46_packet.h>
 #include <vnet/api_errno.h>
+#include <vppinfra/elog.h>
 #include <vppinfra/bihash_8_8.h>
 #include <vppinfra/bihash_16_8.h>
 #include <vppinfra/dlist.h>
@@ -128,6 +129,22 @@
 #undef _
 } nat_config_flags_t;
 
+/* NAT API Logging Levels */
+#define foreach_nat_log_level \
+  _(0x00, LOG_NONE)           \
+  _(0x01, LOG_ERROR)          \
+  _(0x02, LOG_WARNING)        \
+  _(0x03, LOG_NOTICE)         \
+  _(0x04, LOG_INFO)           \
+  _(0x05, LOG_DEBUG)
+
+typedef enum nat_log_level_t_
+{
+#define _(n,f) SNAT_##f = n,
+  foreach_nat_log_level
+#undef _
+} nat_log_level_t;
+
 /* External address and port allocation modes */
 #define foreach_nat_addr_and_port_alloc_alg \
   _(0, DEFAULT, "default")         \
@@ -585,6 +602,8 @@
 
   /* log class */
   vlib_log_class_t log_class;
+  /* logging level */
+  u8 log_level;
 
   /* convenience */
   vlib_main_t *vlib_main;
@@ -744,6 +763,96 @@
 #define nat_log_debug(...)\
   vlib_log(VLIB_LOG_LEVEL_DEBUG, snat_main.log_class, __VA_ARGS__)
 
+#define nat_elog(_level, _str)                    \
+do                                                \
+  {                                               \
+    snat_main_t *sm = &snat_main;                 \
+    if (PREDICT_FALSE (sm->log_level >= _level))  \
+      {                                           \
+        ELOG_TYPE_DECLARE (e) =                   \
+          {                                       \
+            .format = "nat-msg" _str,             \
+            .format_args = "",                    \
+          };                                      \
+        ELOG_DATA (&sm->vlib_main->elog_main, e); \
+      }                                           \
+  } while (0);
+
+#define nat_elog_addr(_level, _str, _addr)               \
+do                                                       \
+  {                                                      \
+    if (PREDICT_FALSE (sm->log_level >= _level))         \
+      {                                                  \
+        ELOG_TYPE_DECLARE (e) =                          \
+          {                                              \
+            .format = "nat-msg " _str " %d.%d.%d.%d",    \
+            .format_args = "i1i1i1i1",                   \
+          };                                             \
+        CLIB_PACKED(struct                               \
+          {                                              \
+            u8 oct1;                                     \
+            u8 oct2;                                     \
+            u8 oct3;                                     \
+            u8 oct4;                                     \
+          }) *ed;                                        \
+        ed = ELOG_DATA (&vlib_global_main.elog_main, e); \
+        ed->oct4 = _addr >> 24;                          \
+        ed->oct3 = _addr >> 16;                          \
+        ed->oct2 = _addr >> 8;                           \
+        ed->oct1 = _addr;                                \
+    }                                                    \
+  } while (0);
+
+#define nat_elog_X1(_level, _fmt, _arg, _val1)         \
+do                                                     \
+  {                                                    \
+    snat_main_t *sm = &snat_main;                      \
+    if (PREDICT_FALSE (sm->log_level >= _level))       \
+      {                                                \
+        ELOG_TYPE_DECLARE (e) =                        \
+          {                                            \
+            .format = "nat-msg " _fmt,                 \
+            .format_args = _arg,                       \
+          };                                           \
+        CLIB_PACKED(struct                             \
+          {                                            \
+            typeof (_val1) val1;                       \
+          }) *ed;                                      \
+        ed = ELOG_DATA (&sm->vlib_main->elog_main, e); \
+        ed->val1 = _val1;                              \
+      }                                                \
+  } while (0);
+
+#define nat_elog_notice(nat_elog_str) \
+  nat_elog(SNAT_LOG_INFO, "[notice] " nat_elog_str)
+
+#define nat_elog_warn(nat_elog_str) \
+  nat_elog(SNAT_LOG_WARNING, "[warning] " nat_elog_str)
+
+#define nat_elog_err(nat_elog_str) \
+  nat_elog(SNAT_LOG_ERROR, "[error] " nat_elog_str)
+
+#define nat_elog_debug(nat_elog_str) \
+  nat_elog(SNAT_LOG_DEBUG, "[debug] " nat_elog_str)
+
+#define nat_elog_info(nat_elog_str) \
+  nat_elog(SNAT_LOG_INFO, "[info] " nat_elog_str)
+
+#define nat_elog_notice_X1(nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1) \
+  nat_elog_X1(SNAT_LOG_NOTICE, "[notice] " nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1)
+
+#define nat_elog_warn_X1(nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1) \
+  nat_elog_X1(SNAT_LOG_WARNING, "[warning] " nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1)
+
+#define nat_elog_err_X1(nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1) \
+  nat_elog_X1(SNAT_LOG_ERROR, "[error] " nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1)
+
+#define nat_elog_debug_X1(nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1) \
+  nat_elog_X1(SNAT_LOG_DEBUG, "[debug] " nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1)
+
+#define nat_elog_info_X1(nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1) \
+  nat_elog_X1(SNAT_LOG_INFO, "[info] " nat_elog_fmt_str, nat_elog_fmt_arg, nat_elog_val1)
+
 /* ICMP session match functions */
 u32 icmp_match_in2out_fast (snat_main_t * sm, vlib_node_runtime_t * node,
 			    u32 thread_index, vlib_buffer_t * b0,
diff --git a/src/plugins/nat/nat44_classify.c b/src/plugins/nat/nat44_classify.c
index 5401b5b..aa2bf73 100644
--- a/src/plugins/nat/nat44_classify.c
+++ b/src/plugins/nat/nat44_classify.c
@@ -154,7 +154,7 @@
 			  next0 = NAT44_CLASSIFY_NEXT_DROP;
 			  b0->error =
 			    node->errors[NAT44_CLASSIFY_ERROR_MAX_REASS];
-			  nat_log_notice ("maximum reassemblies exceeded");
+			  nat_elog_notice ("maximum reassemblies exceeded");
 			  goto enqueue0;
 			}
 		      if (!clib_bihash_search_16_8 (&tsm->in2out_ed, &ed_kv0,
@@ -204,7 +204,7 @@
 		      next0 = NAT44_CLASSIFY_NEXT_DROP;
 		      b0->error =
 			node->errors[NAT44_CLASSIFY_ERROR_MAX_REASS];
-		      nat_log_notice ("maximum reassemblies exceeded");
+		      nat_elog_notice ("maximum reassemblies exceeded");
 		      goto enqueue0;
 		    }
 		  /* check if first fragment has arrived */
@@ -217,7 +217,7 @@
 			{
 			  b0->error =
 			    node->errors[NAT44_CLASSIFY_ERROR_MAX_FRAG];
-			  nat_log_notice
+			  nat_elog_notice
 			    ("maximum fragments per reassembly exceeded");
 			  next0 = NAT44_CLASSIFY_NEXT_DROP;
 			  goto enqueue0;
@@ -288,7 +288,7 @@
 			  next0 = NAT44_CLASSIFY_NEXT_DROP;
 			  b0->error =
 			    node->errors[NAT44_CLASSIFY_ERROR_MAX_REASS];
-			  nat_log_notice ("maximum reassemblies exceeded");
+			  nat_elog_notice ("maximum reassemblies exceeded");
 			  goto enqueue0;
 			}
 		      /* save classification for future fragments and set past
@@ -317,7 +317,7 @@
 		      next0 = NAT44_CLASSIFY_NEXT_DROP;
 		      b0->error =
 			node->errors[NAT44_CLASSIFY_ERROR_MAX_REASS];
-		      nat_log_notice ("maximum reassemblies exceeded");
+		      nat_elog_notice ("maximum reassemblies exceeded");
 		      goto enqueue0;
 		    }
 		  if (reass0->classify_next == NAT_REASS_IP4_CLASSIFY_NONE)
@@ -328,7 +328,7 @@
 			{
 			  b0->error =
 			    node->errors[NAT44_CLASSIFY_ERROR_MAX_FRAG];
-			  nat_log_notice
+			  nat_elog_notice
 			    ("maximum fragments per reassembly exceeded");
 			  next0 = NAT44_CLASSIFY_NEXT_DROP;
 			  goto enqueue0;
diff --git a/src/plugins/nat/nat44_cli.c b/src/plugins/nat/nat44_cli.c
index cfa294f..1a5c683 100644
--- a/src/plugins/nat/nat44_cli.c
+++ b/src/plugins/nat/nat44_cli.c
@@ -116,6 +116,39 @@
 }
 
 static clib_error_t *
+snat_set_log_level_command_fn (vlib_main_t * vm,
+			       unformat_input_t * input,
+			       vlib_cli_command_t * cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  snat_main_t *sm = &snat_main;
+  u8 log_level = SNAT_LOG_NONE;
+  clib_error_t *error = 0;
+
+  /* Get a line of input. */
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return 0;
+
+  if (!unformat (line_input, "level %d", &log_level))
+    {
+      error = clib_error_return (0, "unknown input '%U'",
+				 format_unformat_error, line_input);
+      goto done;
+    }
+  if (log_level > SNAT_LOG_DEBUG)
+    {
+      error = clib_error_return (0, "unknown logging level '%d'", log_level);
+      goto done;
+    }
+  sm->log_level = log_level;
+
+done:
+  unformat_free (line_input);
+
+  return error;
+}
+
+static clib_error_t *
 snat_ipfix_logging_enable_disable_command_fn (vlib_main_t * vm,
 					      unformat_input_t * input,
 					      vlib_cli_command_t * cmd)
@@ -1946,6 +1979,19 @@
 /*?
  * @cliexpar
  * @cliexstart{snat ipfix logging}
+ * To set NAT logging level use:
+ * Set nat logging level
+ * @cliexend
+?*/
+VLIB_CLI_COMMAND (snat_set_log_level_command, static) = {
+  .path = "nat set logging level",
+  .function = snat_set_log_level_command_fn,
+  .short_help = "nat set logging level <level>",
+};
+
+/*?
+ * @cliexpar
+ * @cliexstart{snat ipfix logging}
  * To enable NAT IPFIX logging use:
  *  vpp# nat ipfix logging
  * To set IPFIX exporter use:
diff --git a/src/plugins/nat/nat44_handoff.c b/src/plugins/nat/nat44_handoff.c
index e4cb483..88f1525 100644
--- a/src/plugins/nat/nat44_handoff.c
+++ b/src/plugins/nat/nat44_handoff.c
@@ -68,35 +68,29 @@
 }
 
 static inline uword
-nat44_worker_handoff_fn_inline (vlib_main_t * vm, vlib_node_runtime_t * node,
+nat44_worker_handoff_fn_inline (vlib_main_t * vm,
+				vlib_node_runtime_t * node,
 				vlib_frame_t * frame, u8 is_output,
 				u8 is_in2out)
 {
+  u32 n_enq, n_left_from, *from, do_handoff = 0, same_worker = 0;
+
+  u16 thread_indices[VLIB_FRAME_SIZE], *ti = thread_indices;
+  vlib_buffer_t *bufs[VLIB_FRAME_SIZE], **b = bufs;
   snat_main_t *sm = &snat_main;
-  vlib_buffer_t *bufs[VLIB_FRAME_SIZE], **b;
-  u32 n_enq, n_left_from, *from;
-  u16 thread_indices[VLIB_FRAME_SIZE], *ti;
-  u32 fq_index;
+
   snat_get_worker_function_t *get_worker;
-  u32 thread_index = vm->thread_index;
-  u32 do_handoff = 0, same_worker = 0;
+  u32 fq_index, thread_index = vm->thread_index;
 
   from = vlib_frame_vector_args (frame);
   n_left_from = frame->n_vectors;
-  vlib_get_buffers (vm, from, bufs, n_left_from);
 
-  b = bufs;
-  ti = thread_indices;
-
-  ASSERT (vec_len (sm->workers));
+  vlib_get_buffers (vm, from, b, n_left_from);
 
   if (is_in2out)
     {
+      fq_index = is_output ? sm->fq_in2out_output_index : sm->fq_in2out_index;
       get_worker = sm->worker_in2out_cb;
-      if (is_output)
-	fq_index = sm->fq_in2out_output_index;
-      else
-	fq_index = sm->fq_in2out_index;
     }
   else
     {
@@ -104,49 +98,143 @@
       get_worker = sm->worker_out2in_cb;
     }
 
+  while (n_left_from >= 4)
+    {
+      u32 sw_if_index0, sw_if_index1, sw_if_index2, sw_if_index3;
+      u32 rx_fib_index0 = 0, rx_fib_index1 = 0,
+	rx_fib_index2 = 0, rx_fib_index3 = 0;
+      ip4_header_t *ip0, *ip1, *ip2, *ip3;
+
+      if (PREDICT_TRUE (n_left_from >= 8))
+	{
+	  vlib_prefetch_buffer_header (b[4], STORE);
+	  vlib_prefetch_buffer_header (b[5], STORE);
+	  vlib_prefetch_buffer_header (b[6], STORE);
+	  vlib_prefetch_buffer_header (b[7], STORE);
+	  CLIB_PREFETCH (&b[4]->data, CLIB_CACHE_LINE_BYTES, STORE);
+	  CLIB_PREFETCH (&b[5]->data, CLIB_CACHE_LINE_BYTES, STORE);
+	  CLIB_PREFETCH (&b[6]->data, CLIB_CACHE_LINE_BYTES, STORE);
+	  CLIB_PREFETCH (&b[7]->data, CLIB_CACHE_LINE_BYTES, STORE);
+	}
+
+      ip0 = vlib_buffer_get_current (b[0]);
+      ip1 = vlib_buffer_get_current (b[1]);
+      ip2 = vlib_buffer_get_current (b[2]);
+      ip3 = vlib_buffer_get_current (b[3]);
+
+      if (PREDICT_FALSE (is_in2out))
+	{
+	  sw_if_index0 = vnet_buffer (b[0])->sw_if_index[VLIB_RX];
+	  sw_if_index1 = vnet_buffer (b[1])->sw_if_index[VLIB_RX];
+	  sw_if_index2 = vnet_buffer (b[2])->sw_if_index[VLIB_RX];
+	  sw_if_index3 = vnet_buffer (b[3])->sw_if_index[VLIB_RX];
+
+	  rx_fib_index0 =
+	    ip4_fib_table_get_index_for_sw_if_index (sw_if_index0);
+	  rx_fib_index1 =
+	    ip4_fib_table_get_index_for_sw_if_index (sw_if_index1);
+	  rx_fib_index2 =
+	    ip4_fib_table_get_index_for_sw_if_index (sw_if_index2);
+	  rx_fib_index3 =
+	    ip4_fib_table_get_index_for_sw_if_index (sw_if_index3);
+	}
+
+      ti[0] = get_worker (ip0, rx_fib_index0);
+      ti[1] = get_worker (ip1, rx_fib_index1);
+      ti[2] = get_worker (ip2, rx_fib_index2);
+      ti[3] = get_worker (ip3, rx_fib_index3);
+
+      if (ti[0] == thread_index)
+	same_worker++;
+      else
+	do_handoff++;
+
+      if (ti[1] == thread_index)
+	same_worker++;
+      else
+	do_handoff++;
+
+      if (ti[2] == thread_index)
+	same_worker++;
+      else
+	do_handoff++;
+
+      if (ti[3] == thread_index)
+	same_worker++;
+      else
+	do_handoff++;
+
+      b += 4;
+      ti += 4;
+      n_left_from -= 4;
+    }
+
   while (n_left_from > 0)
     {
       u32 sw_if_index0;
-      u32 rx_fib_index0;
+      u32 rx_fib_index0 = 0;
       ip4_header_t *ip0;
 
-      sw_if_index0 = vnet_buffer (b[0])->sw_if_index[VLIB_RX];
-      rx_fib_index0 = ip4_fib_table_get_index_for_sw_if_index (sw_if_index0);
       ip0 = vlib_buffer_get_current (b[0]);
-      ti[0] = get_worker (ip0, rx_fib_index0);
 
-      if (ti[0] != thread_index)
-	do_handoff++;
-      else
-	same_worker++;
-
-      if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)
-			 && (b[0]->flags & VLIB_BUFFER_IS_TRACED)))
+      if (PREDICT_FALSE (is_in2out))
 	{
-	  nat44_handoff_trace_t *t =
-	    vlib_add_trace (vm, node, b[0], sizeof (*t));
-	  t->next_worker_index = ti[0];
-	  t->trace_index = vlib_buffer_get_trace_index (b[0]);
-	  t->in2out = is_in2out;
+	  sw_if_index0 = vnet_buffer (b[0])->sw_if_index[VLIB_RX];
+	  rx_fib_index0 =
+	    ip4_fib_table_get_index_for_sw_if_index (sw_if_index0);
 	}
 
-      n_left_from -= 1;
-      ti += 1;
+      ti[0] = get_worker (ip0, rx_fib_index0);
+
+      if (ti[0] == thread_index)
+	same_worker++;
+      else
+	do_handoff++;
+
       b += 1;
+      ti += 1;
+      n_left_from -= 1;
     }
 
-  n_enq =
-    vlib_buffer_enqueue_to_thread (vm, fq_index, from, thread_indices,
-				   frame->n_vectors, 1);
+  n_enq = vlib_buffer_enqueue_to_thread (vm, fq_index, from, thread_indices,
+					 frame->n_vectors, 1);
 
   if (n_enq < frame->n_vectors)
-    vlib_node_increment_counter (vm, node->node_index,
-				 NAT44_HANDOFF_ERROR_CONGESTION_DROP,
-				 frame->n_vectors - n_enq);
+    {
+      vlib_node_increment_counter (vm, node->node_index,
+				   NAT44_HANDOFF_ERROR_CONGESTION_DROP,
+				   frame->n_vectors - n_enq);
+    }
+
   vlib_node_increment_counter (vm, node->node_index,
 			       NAT44_HANDOFF_ERROR_SAME_WORKER, same_worker);
   vlib_node_increment_counter (vm, node->node_index,
 			       NAT44_HANDOFF_ERROR_DO_HANDOFF, do_handoff);
+
+  if (PREDICT_FALSE ((node->flags & VLIB_NODE_FLAG_TRACE)))
+    {
+      u32 i;
+      b = bufs;
+      ti = thread_indices;
+
+      for (i = 0; i < frame->n_vectors; i++)
+	{
+	  if (b[0]->flags & VLIB_BUFFER_IS_TRACED)
+	    {
+	      nat44_handoff_trace_t *t =
+		vlib_add_trace (vm, node, b[0], sizeof (*t));
+	      t->next_worker_index = ti[0];
+	      t->trace_index = vlib_buffer_get_trace_index (b[0]);
+	      t->in2out = is_in2out;
+
+	      b++;
+	      ti++;
+	    }
+	  else
+	    break;
+	}
+    }
+
   return frame->n_vectors;
 }
 
diff --git a/src/plugins/nat/nat64.c b/src/plugins/nat/nat64.c
index 748205a..0fe2980 100644
--- a/src/plugins/nat/nat64.c
+++ b/src/plugins/nat/nat64.c
@@ -306,7 +306,7 @@
     {
       if (nat64_db_init (db, bib_buckets, bib_memory_size, st_buckets,
                          st_memory_size, nat64_free_out_addr_and_port))
-	nat_log_err ("NAT64 DB init failed");
+	nat_elog_err ("NAT64 DB init failed");
     }
   /* *INDENT-ON* */
 }
@@ -606,7 +606,7 @@
 	  foreach_snat_protocol
 #undef _
 	default:
-	  nat_log_notice ("unknown protocol");
+	  nat_elog_notice ("unknown protocol");
 	  return;
 	}
       break;
@@ -1120,7 +1120,7 @@
 	  ip6->as_u32[3] = ip4->as_u32;
 	  break;
 	default:
-	  nat_log_notice ("invalid prefix length");
+	  nat_elog_notice ("invalid prefix length");
 	  break;
 	}
     }
@@ -1193,7 +1193,7 @@
       ip4->as_u32 = ip6->as_u32[3];
       break;
     default:
-      nat_log_notice ("invalid prefix length");
+      nat_elog_notice ("invalid prefix length");
       break;
     }
 }
@@ -1278,7 +1278,7 @@
 	case NAT64_CLEANER_RESCHEDULE:
 	  break;
 	default:
-	  nat_log_notice ("unknown event %u", event_type);
+	  nat_elog_notice_X1 ("unknown event %d", "i4", event_type);
 	  break;
 	}
 
diff --git a/src/plugins/nat/nat66.c b/src/plugins/nat/nat66.c
index a6606a4..2caefab 100644
--- a/src/plugins/nat/nat66.c
+++ b/src/plugins/nat/nat66.c
@@ -185,7 +185,7 @@
       kv.key[2] = sm_key.as_u64[2];
       kv.value = sm - nm->sm;
       if (clib_bihash_add_del_24_8 (&nm->sm_l, &kv, 1))
-	nat_log_warn ("nat66-static-map-by-local add key failed");
+	nat_elog_warn ("nat66-static-map-by-local add key failed");
       sm_key.addr.as_u64[0] = e_addr->as_u64[0];
       sm_key.addr.as_u64[1] = e_addr->as_u64[1];
       sm_key.fib_index = 0;
@@ -193,7 +193,7 @@
       kv.key[1] = sm_key.as_u64[1];
       kv.key[2] = sm_key.as_u64[2];
       if (clib_bihash_add_del_24_8 (&nm->sm_e, &kv, 1))
-	nat_log_warn ("nat66-static-map-by-external add key failed");
+	nat_elog_warn ("nat66-static-map-by-external add key failed");
 
       vlib_validate_combined_counter (&nm->session_counters, kv.value);
       vlib_zero_combined_counter (&nm->session_counters, kv.value);
@@ -205,7 +205,7 @@
 
       kv.value = sm - nm->sm;
       if (clib_bihash_add_del_24_8 (&nm->sm_l, &kv, 0))
-	nat_log_warn ("nat66-static-map-by-local delete key failed");
+	nat_elog_warn ("nat66-static-map-by-local delete key failed");
       sm_key.addr.as_u64[0] = e_addr->as_u64[0];
       sm_key.addr.as_u64[1] = e_addr->as_u64[1];
       sm_key.fib_index = 0;
@@ -213,7 +213,7 @@
       kv.key[1] = sm_key.as_u64[1];
       kv.key[2] = sm_key.as_u64[2];
       if (clib_bihash_add_del_24_8 (&nm->sm_e, &kv, 0))
-	nat_log_warn ("nat66-static-map-by-external delete key failed");
+	nat_elog_warn ("nat66-static-map-by-external delete key failed");
       fib_table_unlock (sm->fib_index, FIB_PROTOCOL_IP6,
 			FIB_SOURCE_PLUGIN_HI);
       pool_put (nm->sm, sm);
diff --git a/src/plugins/nat/nat_affinity.c b/src/plugins/nat/nat_affinity.c
index 28c25ae..5a69271 100644
--- a/src/plugins/nat/nat_affinity.c
+++ b/src/plugins/nat/nat_affinity.c
@@ -115,7 +115,7 @@
       kv.key[1] = a->key.as_u64[1];
       pool_put_index (nam->affinity_pool, elt->value);
       if (clib_bihash_add_del_16_8 (&nam->affinity_hash, &kv, 0))
-	nat_log_warn ("affinity key del failed");
+	nat_elog_warn ("affinity key del failed");
       pool_put_index (nam->list_pool, elt_index);
     }
   pool_put_index (nam->list_pool, affinity_per_service_list_head_index);
@@ -151,7 +151,7 @@
 	  pool_put_index (nam->list_pool, a->per_service_index);
 	  pool_put_index (nam->affinity_pool, value.value);
 	  if (clib_bihash_add_del_16_8 (&nam->affinity_hash, &kv, 0))
-	    nat_log_warn ("affinity key del failed");
+	    nat_elog_warn ("affinity key del failed");
 	  rv = 1;
 	  goto unlock;
 	}
@@ -179,7 +179,7 @@
 	  pool_put_index (nam->list_pool, a->per_service_index);
 	  pool_put_index (nam->affinity_pool, kv->value);
 	  if (clib_bihash_add_del_16_8 (&nam->affinity_hash, kv, 0))
-	    nat_log_warn ("affinity key del failed");
+	    nat_elog_warn ("affinity key del failed");
 	  return 1;
 	}
     }
@@ -205,7 +205,7 @@
   if (!clib_bihash_search_16_8 (&nam->affinity_hash, &kv, &value))
     {
       rv = 1;
-      nat_log_notice ("affinity key already exist");
+      nat_elog_notice ("affinity key already exist");
       goto unlock;
     }
 
@@ -216,7 +216,7 @@
 					     affinity_is_expired_cb, NULL);
   if (rv)
     {
-      nat_log_notice ("affinity key add failed");
+      nat_elog_notice ("affinity key add failed");
       pool_put (nam->affinity_pool, a);
       goto unlock;
     }
diff --git a/src/plugins/nat/nat_api.c b/src/plugins/nat/nat_api.c
index 63e1e75..a955731 100644
--- a/src/plugins/nat/nat_api.c
+++ b/src/plugins/nat/nat_api.c
@@ -250,6 +250,33 @@
 }
 
 static void
+vl_api_nat_set_log_level_t_handler (vl_api_nat_set_log_level_t * mp)
+{
+  snat_main_t *sm = &snat_main;
+  vl_api_nat_set_log_level_reply_t *rmp;
+  int rv = 0;
+
+  if (sm->log_level > NAT_LOG_DEBUG)
+    rv = VNET_API_ERROR_UNSUPPORTED;
+  else
+    sm->log_level = mp->log_level;
+
+  REPLY_MACRO (VL_API_NAT_SET_WORKERS_REPLY);
+}
+
+static void *
+vl_api_nat_set_log_level_t_print (vl_api_nat_set_log_level_t *
+				  mp, void *handle)
+{
+  u8 *s;
+
+  s = format (0, "SCRIPT: nat_set_log_level ");
+  s = format (s, "log_level %d", mp->log_level);
+
+  FINISH;
+}
+
+static void
 vl_api_nat_ipfix_enable_disable_t_handler (vl_api_nat_ipfix_enable_disable_t *
 					   mp)
 {
@@ -3523,6 +3550,7 @@
 _(NAT_CONTROL_PING, nat_control_ping)                                   \
 _(NAT_SHOW_CONFIG, nat_show_config)                                     \
 _(NAT_SET_WORKERS, nat_set_workers)                                     \
+_(NAT_SET_LOG_LEVEL, nat_set_log_level)                                 \
 _(NAT_WORKER_DUMP, nat_worker_dump)                                     \
 _(NAT_IPFIX_ENABLE_DISABLE, nat_ipfix_enable_disable)                   \
 _(NAT_SET_REASS, nat_set_reass)                                         \
diff --git a/src/plugins/nat/nat_ha.c b/src/plugins/nat/nat_ha.c
index e81e916..45022a5 100644
--- a/src/plugins/nat/nat_ha.c
+++ b/src/plugins/nat/nat_ha.c
@@ -176,8 +176,15 @@
     return;
 
   ha->in_resync = 0;
-  nat_log_info ("resync completed with result %s",
-		ha->resync_ack_missed ? "FAILED" : "SUCESS");
+  if (ha->resync_ack_missed)
+    {
+      nat_elog_info ("resync completed with result FAILED");
+    }
+  else
+    {
+      nat_elog_info ("resync completed with result SUCCESS");
+    }
+
   if (ha->event_callback)
     ha->event_callback (ha->client_index, ha->pid, ha->resync_ack_missed);
 }
@@ -224,7 +231,8 @@
       }
     vec_free (td->resend_queue[i].data);
     vec_del1 (td->resend_queue, i);
-    nat_log_debug ("ACK for seq %d received", clib_net_to_host_u32 (seq));
+    nat_elog_debug_X1 ("ACK for seq %d received", "i4",
+		       clib_net_to_host_u32 (seq));
 
     return;
   }
@@ -251,8 +259,8 @@
     /* maximum retry reached delete cached data */
     if (td->resend_queue[i].retry_count >= NAT_HA_RETRIES)
       {
-	nat_log_notice ("seq %d missed",
-			clib_net_to_host_u32 (td->resend_queue[i].seq));
+	nat_elog_notice_X1 ("seq %d missed", "i4",
+			    clib_net_to_host_u32 (td->resend_queue[i].seq));
 	if (td->resend_queue[i].is_resync)
 	  {
 	    clib_atomic_fetch_add (&ha->resync_ack_missed, 1);
@@ -267,14 +275,14 @@
       }
 
     /* retry to send non-ACKed data */
-    nat_log_debug ("state sync seq %d resend",
-		   clib_net_to_host_u32 (td->resend_queue[i].seq));
+    nat_elog_debug_X1 ("state sync seq %d resend", "i4",
+		       clib_net_to_host_u32 (td->resend_queue[i].seq));
     td->resend_queue[i].retry_count++;
     vlib_increment_simple_counter (&ha->counters[NAT_HA_COUNTER_RETRY_COUNT],
 				   thread_index, 0, 1);
     if (vlib_buffer_alloc (vm, &bi, 1) != 1)
       {
-	nat_log_warn ("HA NAT state sync can't allocate buffer");
+	nat_elog_warn ("HA NAT state sync can't allocate buffer");
 	return;
       }
     b = vlib_get_buffer (vm, bi);
@@ -368,7 +376,7 @@
 	{
 	  udp_register_dst_port (ha->vlib_main, port, nat_ha_node.index, 1);
 	}
-      nat_log_info ("HA listening on port %d for state sync", port);
+      nat_elog_info_X1 ("HA listening on port %d for state sync", "i4", port);
     }
 
   return 0;
@@ -489,7 +497,8 @@
       nat_ha_recv_refresh (event, now, thread_index);
       break;
     default:
-      nat_log_notice ("Unsupported HA event type %d", event->event_type);
+      nat_elog_notice_X1 ("Unsupported HA event type %d", "i4",
+			  event->event_type);
       break;
     }
 }
@@ -587,7 +596,7 @@
 
       if (vlib_buffer_alloc (vm, &bi, 1) != 1)
 	{
-	  nat_log_warn ("HA NAT state sync can't allocate buffer");
+	  nat_elog_warn ("HA NAT state sync can't allocate buffer");
 	  return;
 	}
 
@@ -783,7 +792,7 @@
   vlib_process_wait_for_event (vm);
   event_type = vlib_process_get_events (vm, &event_data);
   if (event_type)
-    nat_log_info ("nat-ha-process: bogus kickoff event received");
+    nat_elog_info ("nat-ha-process: bogus kickoff event received");
   vec_reset_length (event_data);
 
   while (1)
diff --git a/src/plugins/nat/nat_inlines.h b/src/plugins/nat/nat_inlines.h
index 64b1f25..ae8ed7f 100644
--- a/src/plugins/nat/nat_inlines.h
+++ b/src/plugins/nat/nat_inlines.h
@@ -175,8 +175,6 @@
   snat_user_key_t u_key;
   snat_user_t *u;
 
-  nat_log_debug ("session deleted %U", format_snat_session, tsm, ses);
-
   clib_dlist_remove (tsm->list_pool, ses->per_user_index);
   pool_put_index (tsm->list_pool, ses->per_user_index);
   pool_put (tsm->sessions, ses);
@@ -227,8 +225,6 @@
   if (nat44_is_ses_closed (ses)
       && !(ses->flags & SNAT_SESSION_FLAG_OUTPUT_FEATURE))
     {
-      nat_log_debug ("TCP close connection %U", format_snat_session,
-		     &sm->per_thread_data[thread_index], ses);
       nat_free_session_data (sm, ses, thread_index, 0);
       nat44_delete_session (sm, ses, thread_index);
       return 1;
@@ -261,8 +257,6 @@
     }
   if (nat44_is_ses_closed (ses))
     {
-      nat_log_debug ("TCP close connection %U", format_snat_session,
-		     &sm->per_thread_data[thread_index], ses);
       nat_free_session_data (sm, ses, thread_index, 0);
       nat44_delete_session (sm, ses, thread_index);
       return 1;
diff --git a/src/plugins/nat/nat_ipfix_logging.c b/src/plugins/nat/nat_ipfix_logging.c
index 8cca976..3099e15 100755
--- a/src/plugins/nat/nat_ipfix_logging.c
+++ b/src/plugins/nat/nat_ipfix_logging.c
@@ -675,7 +675,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -774,7 +774,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -860,7 +860,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -951,7 +951,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1039,7 +1039,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1128,7 +1128,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1220,7 +1220,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1312,7 +1312,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1415,7 +1415,7 @@
 
       if (vlib_buffer_alloc (vm, &bi0, 1) != 1)
 	{
-	  nat_log_err ("can't allocate buffer for NAT IPFIX event");
+	  nat_elog_err ("can't allocate buffer for NAT IPFIX event");
 	  return;
 	}
 
@@ -1826,7 +1826,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
     }
@@ -1837,7 +1837,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1846,7 +1846,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1855,7 +1855,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1864,7 +1864,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1873,7 +1873,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1882,7 +1882,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4",rv);
 	  return -1;
 	}
 
@@ -1891,7 +1891,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1900,7 +1900,7 @@
       rv = vnet_flow_report_add_del (frm, &a, NULL);
       if (rv)
 	{
-	  nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+	  nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
 	  return -1;
 	}
 
@@ -1911,7 +1911,7 @@
           rv = vnet_flow_report_add_del (frm, &a, NULL);
           if (rv)
             {
-              nat_log_warn ("vnet_flow_report_add_del returned %d", rv);
+              nat_elog_warn_X1 ("vnet_flow_report_add_del returned %d", "i4", rv);
               return -1;
             }
         }
diff --git a/src/plugins/nat/nat_reass.c b/src/plugins/nat/nat_reass.c
index 673acfa..b518c0c 100755
--- a/src/plugins/nat/nat_reass.c
+++ b/src/plugins/nat/nat_reass.c
@@ -232,7 +232,7 @@
 
   if (srm->ip4_reass_n >= srm->ip4_max_reass)
     {
-      nat_log_warn ("no free resassembly slot");
+      nat_elog_warn ("no free resassembly slot");
       goto unlock;
     }
 
@@ -263,7 +263,7 @@
   reass->flags = 0;
   reass->classify_next = NAT_REASS_IP4_CLASSIFY_NONE;
   if (clib_bihash_add_del_16_8 (&srm->ip4_reass_hash, &kv, 1))
-    nat_log_warn ("ip4_reass_hash add key failed");
+    nat_elog_warn ("ip4_reass_hash add key failed");
 
 unlock:
   clib_spinlock_unlock_if_init (&srm->ip4_reass_lock);
@@ -326,7 +326,7 @@
 	{
 	  clib_dlist_addhead (srm->ip4_reass_lru_list_pool,
 			      srm->ip4_reass_head_index, oldest_index);
-	  nat_log_warn ("no free resassembly slot");
+	  nat_elog_warn ("no free resassembly slot");
 	  reass = 0;
 	  goto unlock;
 	}
@@ -535,7 +535,7 @@
 	{
 	  clib_dlist_addhead (srm->ip6_reass_lru_list_pool,
 			      srm->ip6_reass_head_index, oldest_index);
-	  nat_log_warn ("no free resassembly slot");
+	  nat_elog_warn ("no free resassembly slot");
 	  reass = 0;
 	  goto unlock;
 	}
diff --git a/src/plugins/nat/out2in.c b/src/plugins/nat/out2in.c
index 3d045a9..8c6cb48 100755
--- a/src/plugins/nat/out2in.c
+++ b/src/plugins/nat/out2in.c
@@ -129,7 +129,7 @@
     {
       s_kv.key = s->in2out.as_u64;
       if (clib_bihash_add_del_8_8 (&tsm->in2out, &s_kv, 0))
-	nat_log_warn ("out2in key del failed");
+	nat_elog_warn ("out2in key del failed");
 
       snat_ipfix_logging_nat44_ses_delete (ctx->thread_index,
 					   s->in2out.addr.as_u32,
@@ -192,7 +192,7 @@
   if (PREDICT_FALSE (maximum_sessions_exceeded (sm, thread_index)))
     {
       b0->error = node->errors[SNAT_OUT2IN_ERROR_MAX_SESSIONS_EXCEEDED];
-      nat_log_notice ("maximum sessions exceeded");
+      nat_elog_notice ("maximum sessions exceeded");
       return 0;
     }
 
@@ -203,7 +203,7 @@
     nat_user_get_or_create (sm, &in2out.addr, in2out.fib_index, thread_index);
   if (!u)
     {
-      nat_log_warn ("create NAT user failed");
+      nat_elog_warn ("create NAT user failed");
       return 0;
     }
 
@@ -211,7 +211,7 @@
   if (!s)
     {
       nat44_delete_user_with_no_session (sm, u, thread_index);
-      nat_log_warn ("create NAT session failed");
+      nat_elog_warn ("create NAT session failed");
       return 0;
     }
 
@@ -231,14 +231,14 @@
   if (clib_bihash_add_or_overwrite_stale_8_8
       (&sm->per_thread_data[thread_index].in2out, &kv0,
        nat44_i2o_is_idle_session_cb, &ctx0))
-    nat_log_notice ("in2out key add failed");
+    nat_elog_notice ("in2out key add failed");
 
   kv0.key = s->out2in.as_u64;
 
   if (clib_bihash_add_or_overwrite_stale_8_8
       (&sm->per_thread_data[thread_index].out2in, &kv0,
        nat44_o2i_is_idle_session_cb, &ctx0))
-    nat_log_notice ("out2in key add failed");
+    nat_elog_notice ("out2in key add failed");
 
   /* log NAT event */
   snat_ipfix_logging_nat44_ses_create (thread_index,
@@ -1443,7 +1443,7 @@
 	    {
 	      next0 = SNAT_OUT2IN_NEXT_DROP;
 	      b0->error = node->errors[SNAT_OUT2IN_ERROR_MAX_REASS];
-	      nat_log_notice ("maximum reassemblies exceeded");
+	      nat_elog_notice ("maximum reassemblies exceeded");
 	      goto trace0;
 	    }
 
@@ -1548,7 +1548,7 @@
 		      (thread_index, reass0, bi0, &fragments_to_drop))
 		    {
 		      b0->error = node->errors[SNAT_OUT2IN_ERROR_MAX_FRAG];
-		      nat_log_notice
+		      nat_elog_notice
 			("maximum fragments per reassembly exceeded");
 		      next0 = SNAT_OUT2IN_NEXT_DROP;
 		      goto trace0;
diff --git a/src/plugins/nat/out2in_ed.c b/src/plugins/nat/out2in_ed.c
index 7e98480..560c23e 100644
--- a/src/plugins/nat/out2in_ed.c
+++ b/src/plugins/nat/out2in_ed.c
@@ -167,7 +167,7 @@
       ed_kv.key[0] = ed_key.as_u64[0];
       ed_kv.key[1] = ed_key.as_u64[1];
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &ed_kv, 0))
-	nat_log_warn ("in2out_ed key del failed");
+	nat_elog_warn ("in2out_ed key del failed");
 
       if (snat_is_unk_proto_session (s))
 	goto delete;
@@ -244,14 +244,14 @@
   if (PREDICT_FALSE (maximum_sessions_exceeded (sm, thread_index)))
     {
       b->error = node->errors[NAT_OUT2IN_ED_ERROR_MAX_SESSIONS_EXCEEDED];
-      nat_log_notice ("maximum sessions exceeded");
+      nat_elog_notice ("maximum sessions exceeded");
       return 0;
     }
 
   u = nat_user_get_or_create (sm, &l_key.addr, l_key.fib_index, thread_index);
   if (!u)
     {
-      nat_log_warn ("create NAT user failed");
+      nat_elog_warn ("create NAT user failed");
       return 0;
     }
 
@@ -259,7 +259,7 @@
   if (!s)
     {
       nat44_delete_user_with_no_session (sm, u, thread_index);
-      nat_log_warn ("create NAT session failed");
+      nat_elog_warn ("create NAT session failed");
       return 0;
     }
 
@@ -288,7 +288,7 @@
   if (clib_bihash_add_or_overwrite_stale_16_8 (&tsm->out2in_ed, &kv,
 					       nat44_o2i_ed_is_idle_session_cb,
 					       &ctx))
-    nat_log_notice ("out2in-ed key add failed");
+    nat_elog_notice ("out2in-ed key add failed");
 
   if (twice_nat == TWICE_NAT || (twice_nat == TWICE_NAT_SELF &&
 				 ip->src_address.as_u32 == l_key.addr.as_u32))
@@ -302,7 +302,7 @@
 	  b->error = node->errors[NAT_OUT2IN_ED_ERROR_OUT_OF_PORTS];
 	  nat44_delete_session (sm, s, thread_index);
 	  if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &kv, 0))
-	    nat_log_notice ("out2in-ed key del failed");
+	    nat_elog_notice ("out2in-ed key del failed");
 	  return 0;
 	}
       s->ext_host_nat_addr.as_u32 = eh_key.addr.as_u32;
@@ -320,7 +320,7 @@
   if (clib_bihash_add_or_overwrite_stale_16_8 (&tsm->in2out_ed, &kv,
 					       nat44_i2o_ed_is_idle_session_cb,
 					       &ctx))
-    nat_log_notice ("in2out-ed key add failed");
+    nat_elog_notice ("in2out-ed key add failed");
 
   snat_ipfix_logging_nat44_ses_create (thread_index,
 				       s->in2out.addr.as_u32,
@@ -461,7 +461,7 @@
 				  thread_index);
       if (!u)
 	{
-	  nat_log_warn ("create NAT user failed");
+	  nat_elog_warn ("create NAT user failed");
 	  return;
 	}
 
@@ -469,7 +469,7 @@
       if (!s)
 	{
 	  nat44_delete_user_with_no_session (sm, u, thread_index);
-	  nat_log_warn ("create NAT session failed");
+	  nat_elog_warn ("create NAT session failed");
 	  return;
 	}
 
@@ -492,7 +492,7 @@
 
       kv.value = s - tsm->sessions;
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &kv, 1))
-	nat_log_notice ("in2out_ed key add failed");
+	nat_elog_notice ("in2out_ed key add failed");
     }
 
   if (ip->protocol == IP_PROTOCOL_TCP)
@@ -674,7 +674,7 @@
       if (PREDICT_FALSE (maximum_sessions_exceeded (sm, thread_index)))
 	{
 	  b->error = node->errors[NAT_OUT2IN_ED_ERROR_MAX_SESSIONS_EXCEEDED];
-	  nat_log_notice ("maximum sessions exceeded");
+	  nat_elog_notice ("maximum sessions exceeded");
 	  return 0;
 	}
 
@@ -694,7 +694,7 @@
 				  thread_index);
       if (!u)
 	{
-	  nat_log_warn ("create NAT user failed");
+	  nat_elog_warn ("create NAT user failed");
 	  return 0;
 	}
 
@@ -703,7 +703,7 @@
       if (!s)
 	{
 	  nat44_delete_user_with_no_session (sm, u, thread_index);
-	  nat_log_warn ("create NAT session failed");
+	  nat_elog_warn ("create NAT session failed");
 	  return 0;
 	}
 
@@ -721,13 +721,13 @@
       /* Add to lookup tables */
       s_kv.value = s - tsm->sessions;
       if (clib_bihash_add_del_16_8 (&tsm->out2in_ed, &s_kv, 1))
-	nat_log_notice ("out2in key add failed");
+	nat_elog_notice ("out2in key add failed");
 
       make_ed_kv (&s_kv, &ip->dst_address, &ip->src_address, ip->protocol,
 		  m->fib_index, 0, 0);
       s_kv.value = s - tsm->sessions;
       if (clib_bihash_add_del_16_8 (&tsm->in2out_ed, &s_kv, 1))
-	nat_log_notice ("in2out key add failed");
+	nat_elog_notice ("in2out key add failed");
     }
 
   /* Update IP checksum */
@@ -1733,7 +1733,7 @@
 	    {
 	      next0 = NAT44_ED_OUT2IN_NEXT_DROP;
 	      b0->error = node->errors[NAT_OUT2IN_ED_ERROR_MAX_REASS];
-	      nat_log_notice ("maximum reassemblies exceeded");
+	      nat_elog_notice ("maximum reassemblies exceeded");
 	      goto trace0;
 	    }
 
@@ -1865,7 +1865,7 @@
 		      (thread_index, reass0, bi0, &fragments_to_drop))
 		    {
 		      b0->error = node->errors[NAT_OUT2IN_ED_ERROR_MAX_FRAG];
-		      nat_log_notice
+		      nat_elog_notice
 			("maximum fragments per reassembly exceeded");
 		      next0 = NAT44_ED_OUT2IN_NEXT_DROP;
 		      goto trace0;
