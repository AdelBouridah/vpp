syntax = "proto3";

package interfaces;

message Interface {
    string name = 1;                   /* Logical interface name unique across all configured interfaces (mandatory) */
    uint32 vrf = 2;

    enum Type {
        UNDEFINED = 0;
        SOFTWARE_LOOPBACK = 1;
        ETHERNET_CSMACD = 2;
        MEMORY_INTERFACE = 3;
        TAP_INTERFACE = 4;
        AF_PACKET_INTERFACE = 5;
        VXLAN_TUNNEL = 6;
    };
    Type type = 3;

    bool enabled = 4;
    string phys_address = 5;
    repeated string ip_addresses = 6;  /* IP addresses in the format <ipAddress>/<ipPrefix> */
    bool set_dhcp_client = 7;
    uint32 mtu = 8;

    message Unnumbered {
        bool is_unnumbered = 1;
        string interface_with_ip = 2;
    }
    Unnumbered unnumbered = 9;

    message RxModeSettings {
        // from vpp/build-root/install-vpp-native/vpp/include/vnet/interface.h
        enum RxModeType {
            UNKNOWN = 0;
            POLLING = 1;
            INTERRUPT = 2;
            ADAPTIVE = 3;
            DEFAULT = 4;
        };
        RxModeType rx_mode = 1;
        uint32 queue_id  = 2;
        uint32 queue_id_valid  = 3;
    }
    RxModeSettings rx_mode_settings = 10;

    message RxPlacementSettings {
        uint32 queue = 1;
        uint32 worker = 2;
        bool is_main = 3;
    }
    RxPlacementSettings rx_placement_settings = 11;

    message MemifLink {
        bool master = 1;
        enum MemifMode {
            ETHERNET = 0;
            IP = 1;
            PUNT_INJECT = 2;
        }
        MemifMode mode = 2;
        uint32 id = 3;              /* 32bit integer used to authenticate and match opposite sides of the connection */
        string socket_filename = 4; /* filename of the socket used for connection establishment */
        string secret = 5;
        uint32 ring_size = 6;       /* the number of entries of RX/TX rings */
        uint32 buffer_size = 7;     /* size of the buffer allocated for each ring entry */
        uint32 rx_queues = 8;       /* number of rx queues (only valid for slave) */
        uint32 tx_queues = 9;       /* number of tx queues (only valid for slave) */
    }

    message VxlanLink {
        string src_address = 1;  /* source VTEP address */
        string dst_address = 2;  /* destination VTEP address */
        uint32 vni = 3;          /* VXLAN Network Identifier */
        string multicast = 4;    /* multicast interface */

    }

    message AfpacketLink {
        string host_if_name = 1; /* name of the host interface to bind to (mandatory) */
    }

    message TapLink {
        uint32 version = 1;         /* 1 / unset = use the original TAP interface; 2 = use a fast virtio-based TAP */
        string host_if_name = 2;    /* name of the TAP interface in the host OS;
                                       if empty, it will be auto-generated (suitable for combination with TAP_TO_VPP
                                       interface from Linux ifplugin, because then this name is only temporary anyway)
                                     */
        string to_microservice = 3; /* if TAP connects VPP with microservice, fill this parameter with the target
                                       microservice name - should match with the namespace reference of the associated
                                       TAP_TO_VPP interface (it is still moved to the namespace by Linux-ifplugin but
                                       VPP-ifplugin needs to be aware of this dependency) */
        uint32 rx_ring_size = 4;    /* Rx ring buffer size; must be power of 2; default is 256; only for TAP v.2 */
        uint32 tx_ring_size = 5;    /* Tx ring buffer size; must be power of 2; default is 256; only for TAP v.2 */
    }

    oneof link {
        MemifLink memif = 101;       /* memif-specific configuration */
        VxlanLink vxlan = 102;       /* VXLAN-specific configuration */
        AfpacketLink afpacket = 103; /* AF-packet-specific configuration */
        TapLink tap = 104;           /* TAP-specific configuration */
    };
};
